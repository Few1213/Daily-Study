<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    1.0 
    面向过程和面向对象都是编程的思想,方式不一样
    面向过程:凡事都亲力亲为,所有的代码都要自己写,每一步都要很清楚,注重的是过程
    面向对象:执行者成为指挥者,只要找对象,然后让对象做相关的事情,注重结果
    面向对象的特性:封装,继承,多态
    封装:就是代码的封装,吧一些特征和行为封装在对象中
    面向对象的编程思想,根据需求,抽象出相关的对象,总结对象的特征和行为,把特征变成行为,行为变成方法,然后定义(js)构造函数,实例化对象,通过调用对象的属性和方法,完成相应的需求----编程思想


    对象:具体特指的某个事物,有特征和行为也就是属性和方法



    如何创建对象
    通过调用new Object(),还有{},自定义构造函数

    创建对象的方式
    1.调用系统Object()---->创建出来的都是Object类型的,不能很明确的出这个对象属于什么类型

    2.字面量的方式{}===>只能创建一个对象(一次只能创建一个)    
    
    3.工厂模式创建对象------>推论------>自定义构造函数的方式
    自定义构造函数(优化后的工厂模式)

    自定义函数创建对象发生的四件事情
    1.在内存中申请一块空想的空间,储存创建的对象
    2.this就是当前的实例化对象
    3.设置当前的对象中的额属性和方法(为对象添加属性和方法,为属性和方法复制)
    4.把创建后的对象返回

    都是需要通过new的形式




    2.0 原型
    构造函数中有一个属性prototype,是原型,程序员使用的
    实例对象中有一个属性__proto__,是原型,浏览器使用的,不是很标准的
    实例对象中的__proto__指向的就是该实例对象中的构造函数中的prototype
    构造函数中的prototype里面的属性和方法.可以直接通过实例对象调用
    正常的写法:实例对象.__proto__才能访问到构造函数中的prototype中的属性或者方法
    原型就是属性,而这个属性也是一个对象
    Person.prototype----->是属性
    Person.prototype.属性或者Person.prototype.方法()

    本身在构造函数中定义的属性和方法,在实例化对象的时候,实例化对象中的属性和方法都是在自己的空间存在的,如果是多个对象,这些属性和方法都会在单独的空间中存在,浪费内存空间,所以,为了数据空想,想要把节省的空间的属性和方法卸载原型对象中,达到了数据共享,节省了内存空间


    原型的作用之一:数据共享,节省了内存空间

    原型的写法:
    构造函数.prototype.属性=值
    构造函数.prototype.方法=值---函数.prototype,函数也是对象,所以函数中也有__proto__

    实例对象.prototype--->实例对象中没有这个属性,只有__proto__

    简单的原型的写法
    缺陷:原型直接指向{},就是一个对象,没有构造器
    构造函数.prototype={
        切记,如果用这种写法,一定要把构造器加上(constructor)
    }

    通过原型为内置对象添加原型的属性或者方法--->原因:
    系统的内置对象的属性和方法可能不满足现在需求,所以可以通过原型的方法加入属性或者方法,为了方便开发

    为内置对象中的原型添加属性或者方法,那么这个内置对象的实例对象就可以直接使用了
    String.prototype.方法=匿名函数;
    var str="哈哈";
    str.方法();--->实例对象可以直接调用原型中的属性或者方法

    3.0 继承
    
    1.通过原型实现继承 ,改变原型的指向,属性在初始化的时候就已经固定了,如果是多个对象实例化 ,name每个实例化对象的属性的值在初始化的时候都是一样的
    2.借用构造函数继承,不能继承方法
    3.组合继承,可以解决属性和方法继承的问题
    4.拷贝继承,就是把一个对象中的原型中的所有的属性和方法复制给另一个对象


    4.0 函数中的this的指向
    普通函数中this的指向是window
    构造函数中的this,构造函数一般都是创建实例化对象使用的,是通过new关键字,构造函数也是函数
    构造函数中的this指向的是实例化对象
    方法中的this指向的也是实例化对象
    原型中的this指向的也是实例对象
    定时器中的this指向的是window


    函数是对象,构造函数也是函数,也是对象

    5.0 apply和call方法的使用

     都可以改变this的指向
     使用方式:
     函数名.apply(对象,[参数1,参数,参数3,....] );
     函数名.call(对象,参数1,参数2,参数3,...);
     我想用使用其他对象的摸个方法,   其他对象,方法名.apply(当前对象,参数);
     这个方法就会被当前的对象所使用,同时这个方法中的this就是当前的对象,在调用方法的时候改变了this
     的指向

    6.0 bind方法
    bind的方法的使用和区别
    复制一个方法或者函数,在复制的同时改变了this的指向
    使用方式:
    函数名.bind(对象,参数1,参数2,...);---->返回值是复制后的这个函数

    高阶函数--->函数的使用方式:函数作为参数使用,函数作为返回值使用
    函数作为参数使用的时候,这个函数可以是匿名函数也可以是命名函数

    7.0 作用域及作用域链及预解析

    8.0 闭包
    函数中有另一个函数,或者是行数中有另一个对象,里面的函数或者是对象都可以使用外面函数中定义的变量或者数据,此时形成闭包

    function f1(num){
        return function () { 
            console.log(num);
         }
    } 
    f1(20);

    闭包模式:函数模式闭包,对象模式闭包
    闭包的作用:缓存数据,延长作用域链,同时也是缺点,函数中的变量不能及时的释放


    9.0 沙箱
    沙箱就是一个环境也可以叫黑盒,在这个环境中模拟外面真实的开发环境,完成需求,效果和外面真实的开发环境是一样的

    10.0 递归

    函数中调用函数自己,递归一定要有结束的条件,不然就是死循环
    递归一般应用在遍历上递归不要轻易使用,效率很低


    11.0 正则


    补充

    1 - 逻辑中断 
    &&:从左到右,找假值,如果找到了,逻辑就中断,返回假值(返回值是布尔类型为 false 的那个值得本身)
    ||:从左到右找真值(布尔类型为true),如果找到了,逻辑就中断,返回真值

    2 - 值类型和引用类型
    值类型在赋值的时候,是把值的本身赋值给了变量,传递的是值本身
    引用类型在赋值的时候,赋值的是地址,传递的是地址

    3 - 相等转换原则(往下匹配,一条一条匹配,匹配到了就直接运用)(重要)
        1. NaN 与任何值不相等,包括他自己
        2. null 与任何值不相等,除了 null 和 undefined
        3. undefined 与任何值不相等,除了 null 和 undefined
        4. 如果操作数两边有数字或者是布尔,都转成数字进行比较
        5. 如果操作数两边有字符串,都转成字符串进行比较
        6. 如果操作数两边都是复杂数据类型,那就比较地址


    总结: NaN与任何值不相等, null 和 undefined 和任何值不相等,除了 null 和 undefined ,转换的时候, 数字 > 字符串 > 复杂数据类型

    4 - 原型
    访问原型对象有两种方式
        1 - 构造函数的prototype
        2 - 实例对象的__proto__
    使用注意点:
        不要通过实例对象来修改原型上的东西,__开头的东西,是浏览器的私有属性,不希望被修改,而且存在浏览器兼容性的问题

    constructor 属性: 是原型中默认自带的属性,指向了当前的构造函数

    原型链:任何对象都有__proto__属性,指向了原型对象,原型对象也是对象,原型对象也有__proto__属性,指向了原型对象的原型对象,所以说,原型对象也有自己的原型对象,这样形成的一条链式结构,就叫原型链

    5 - Object.prototype 成员介绍
    任何对象的原型链上都有 Object.prototype
    constructor : 指向了构造函数的 Object
    hasOwnProperty :  有自己的属性 (和 in 运算符有差别)
        语法: 对象.hasOwnProperty("属性");
        作用; 判断该属性是否是对象自身的(!!!对象自身),如果是则返回true,不然就返回false

        in 运算符: 判断属性能否被对象访问到,不管属性是对象自身的,还是原型链上的,只要能够访问到,就返回true,如果不能访问到就返回false

    isPrototypeOf: 是否是原型归属
    propertyIsEnumerable : 属性是否枚举(遍历)
        语法: 对象.propertyIsEnumerable("属性")
        作用: 判断属性是否可遍历
            1 - 判断属性是否是对象自身的
            2 - 判断属性是否可以遍历
            只要满足了上面两个条件才返回true
            !!!说明Object.prototype上自带的成员默认都是不可遍历的
            !!!手动给对象添加的属性默认是可以遍历的

            给对象添加一个不可枚举(遍历)的属性 Object.defineProperty()
            语法: Object.defineProperty(obj, prop, desc);
            参数说明:
            obj: 都给对象添加属性,指定是哪个对象
            prop: 给对象添加什么属性,是个字符串
            desc: 属性描述符,是个对象
            例子 Object.defineProperty(obj, "gender",{
                value: "female",    //value 给这个对象的该属性设置默认值
                enumerable: true,   //enumerable 设置属性是否可以遍历,true 可以遍历
                writable: false     //writable 设置属性是否可以修改,true可修改
            })
            
    toLocaleString toString valueOf






    </script>
</body>
</html>