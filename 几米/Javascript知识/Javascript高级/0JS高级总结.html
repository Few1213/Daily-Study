<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    1.0 
    面向过程和面向对象都是编程的思想,方式不一样
    面向过程:凡事都亲力亲为,所有的代码都要自己写,每一步都要很清楚,注重的是过程
    面向对象:执行者成为指挥者,只要找对象,然后让对象做相关的事情,注重结果
    面向对象的特性:封装,继承,多态
    封装:就是代码的封装,吧一些特征和行为封装在对象中
    面向对象的编程思想,根据需求,抽象出相关的对象,总结对象的特征和行为,把特征变成行为,行为变成方法,然后定义(js)构造函数,实例化对象,通过调用对象的属性和方法,完成相应的需求----编程思想


    对象:具体特指的某个事物,有特征和行为也就是属性和方法



    如何创建对象
    通过调用new Object(),还有{},自定义构造函数

    创建对象的方式
    1.调用系统Object()---->创建出来的都是Object类型的,不能很明确的出这个对象属于什么类型

    2.字面量的方式{}===>只能创建一个对象(一次只能创建一个)    
    
    3.工厂模式创建对象------>推论------>自定义构造函数的方式
    自定义构造函数(优化后的工厂模式)

    自定义函数创建对象发生的四件事情
    1.在内存中申请一块空想的空间,储存创建的对象
    2.this就是当前的实例化对象
    3.设置当前的对象中的额属性和方法(为对象添加属性和方法,为属性和方法复制)
    4.把创建后的对象返回

    都是需要通过new的形式




    2.0 原型
    构造函数中有一个属性prototype,是原型,程序员使用的
    实例对象中有一个属性__proto__,是原型,浏览器使用的,不是很标准的
    实例对象中的__proto__指向的就是该实例对象中的构造函数中的prototype
    构造函数中的prototype里面的属性和方法.可以直接通过实例对象调用
    正常的写法:实例对象.__proto__才能访问到构造函数中的prototype中的属性或者方法
    原型就是属性,而这个属性也是一个对象
    Person.prototype----->是属性
    Person.prototype.属性或者Person.prototype.方法()

    本身在构造函数中定义的属性和方法,在实例化对象的时候,实例化对象中的属性和方法都是在自己的空间存在的,如果是多个对象,这些属性和方法都会在单独的空间中存在,浪费内存空间,所以,为了数据空想,想要把节省的空间的属性和方法卸载原型对象中,达到了数据共享,节省了内存空间


    原型的作用之一:数据共享,节省了内存空间

    原型的写法:
    构造函数.prototype.属性=值
    构造函数.prototype.方法=值---函数.prototype,函数也是对象,所以函数中也有__proto__

    实例对象.prototype--->实例对象中没有这个属性,只有__proto__

    简单的原型的写法
    缺陷:原型直接指向{},就是一个对象,没有构造器
    构造函数.prototype={
        切记,如果用这种写法,一定要把构造器加上(constructor)
    }

    通过原型为内置对象添加原型的属性或者方法--->原因:
    系统的内置对象的属性和方法可能不满足现在需求,所以可以通过原型的方法加入属性或者方法,为了方便开发

    为内置对象中的原型添加属性或者方法,那么这个内置对象的实例对象就可以直接使用了
    String.prototype.方法=匿名函数;
    var str="哈哈";
    str.方法();--->实例对象可以直接调用原型中的属性或者方法

    3.0 继承
    
    1.通过原型实现继承 ,改变原型的指向,属性在初始化的时候就已经固定了,如果是多个对象实例化 ,name每个实例化对象的属性的值在初始化的时候都是一样的
    2.借用构造函数继承,不能继承方法
    3.组合继承,可以解决属性和方法继承的问题
    4.拷贝继承,就是把一个对象中的原型中的所有的属性和方法复制给另一个对象


    4.0 函数中的this的指向
    普通函数中this的指向是window
    构造函数中的this,构造函数一般都是创建实例化对象使用的,是通过new关键字,构造函数也是函数
    构造函数中的this指向的是实例化对象
    方法中的this指向的也是实例化对象
    原型中的this指向的也是实例对象
    定时器中的this指向的是window


    函数是对象,构造函数也是函数,也是对象

    5.0 apply和call方法的使用

     都可以改变this的指向
     使用方式:
     函数名.apply(对象,[参数1,参数,参数3,....] );
     函数名.call(对象,参数1,参数2,参数3,...);
     我想用使用其他对象的摸个方法,   其他对象,方法名.apply(当前对象,参数);
     这个方法就会被当前的对象所使用,同时这个方法中的this就是当前的对象,在调用方法的时候改变了this
     的指向

    6.0 bind方法
    bind的方法的使用和区别
    复制一个方法或者函数,在复制的同时改变了this的指向
    使用方式:
    函数名.bind(对象,参数1,参数2,...);---->返回值是复制后的这个函数

    高阶函数--->函数的使用方式:函数作为参数使用,函数作为返回值使用
    函数作为参数使用的时候,这个函数可以是匿名函数也可以是命名函数

    7.0 作用域及作用域链及预解析

    8.0 闭包
    函数中有另一个函数,或者是行数中有另一个对象,里面的函数或者是对象都可以使用外面函数中定义的变量或者数据,此时形成闭包

    function f1(num){
        return function () { 
            console.log(num);
         }
    } 
    f1(20);

    闭包模式:函数模式闭包,对象模式闭包
    闭包的作用:缓存数据,延长作用域链,同时也是缺点,函数中的变量不能及时的释放


    9.0 沙箱
    沙箱就是一个环境也可以叫黑盒,在这个环境中模拟外面真实的开发环境,完成需求,效果和外面真实的开发环境是一样的

    10.0 递归

    函数中调用函数自己,递归一定要有结束的条件,不然就是死循环
    递归一般应用在遍历上递归不要轻易使用,效率很低


    11.0 正则
    















    </script>
</body>
</html>